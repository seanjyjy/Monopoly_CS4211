#include "constant.csp";
#include "player.pcsp";
#include "move.pcsp";
#import "UtilsNew";

// comment out the desired board to try its configuration
#include "board.csp";
// #include "board1.csp";
// #include "board2.csp";
// #include "board3.csp";
// #include "board4.csp";

/* TODO: change the probability of these numbers since it has already been changed in some logic

Note each round denotes a player action, rather than a set of complete player actions
Round 5: P1 -> P2 -> P1 -> P2 -> P1

Board0: simulates a clean slate of the monopoly game. Running with number of rounds to reach 6, takes around 16s. 
#assert Game reaches gameEndConditionBoundedRoundP1Win with prob -> [0.20826, 0.47523]
#assert Game reaches gameEndConditionBoundedRoundP2Win with prob -> [0.09341, 0.78356]

Board1: simulates where p1 and p2 have equal number of houses after round 5 of the monopoly game. Running with number of rounds to reach 13, takes around 10-16s. 
#assert Game reaches gameEndConditionBoundedRoundP1Win with prob -> [0.18375, 0.73506]
#assert Game reaches gameEndConditionBoundedRoundP2Win with prob -> [0, 0.28741]

Board2: simulates a where p1 have more number of houses than p2 after round 5 of the monopoly game. Running with number of rounds to reach 13, takes around 10s. 
#assert Game reaches gameEndConditionBoundedRoundP1Win with prob -> [0.7375, 1]
#assert Game reaches gameEndConditionBoundedRoundP2Win with prob -> [0, 0.01237] 

Board3: simulates a low occurence game where p1 has lesser houses than p2 after round 5 of the monopoly game. Running with number of rounds to reach 12, takes around 10s. 
#assert Game reaches gameEndConditionBoundedRoundP1Win with prob -> [0.35459, 0.95268];
#assert Game reaches gameEndConditionBoundedRoundP2Win with prob -> [0.79818, 1]

*/

// TODO: ADD INTERMEDIATE EVENTS (EVEN IF DUMMY) FOR ALL ACTIONS SO THAT IT SHOWS UP IN TRACE
// e.g. what round is it (before roll), no need pay rent, no money buy property, bankrupt condition, does curr property have owner
// DONE!!!

// TODO: check why p2 always win with such huge probability when starting money is low (vary your variables e.g. can only roll 1 for dice)
// DONE!!!

// Note if we are using board 0, max at round = 6/7 as the dimensions can get too large
// if using board 1-3, can feel free to try 10-13 (can take up till 16s max)

var roundsToPlay = 6;
var dummyVar = 0; // For dummy event so it shows up in trace

Game = [round < roundsToPlay] roundNo.round { dummyVar = 0; } -> roll(round % 2) 
	   []
	   [round >= roundsToPlay] gameEnd.round { dummyVar = 0; } -> Skip; // Exit simulation to prevent deadlock

boardChecker(player) = [money[player] >= 0] Game
				       []
					   [money[player] < 0] bankruptGameEnd.player { round = roundsToPlay } -> Skip;

#define gameEndConditionBoundedRoundP1Win round == roundsToPlay && call(didFirstWinSecond, p1, p2, money, properties, propertyFieldCount, owner, cost);
#assert Game reaches gameEndConditionBoundedRoundP1Win;
#assert Game reaches gameEndConditionBoundedRoundP1Win with pmin;
#assert Game reaches gameEndConditionBoundedRoundP1Win with pmax;
#assert Game reaches gameEndConditionBoundedRoundP1Win with prob;

#define gameEndConditionBoundedRoundP2Win round == roundsToPlay && call(didFirstWinSecond, p2, p1, money, properties, propertyFieldCount, owner, cost);
#assert Game reaches gameEndConditionBoundedRoundP2Win;
#assert Game reaches gameEndConditionBoundedRoundP2Win with pmin;
#assert Game reaches gameEndConditionBoundedRoundP2Win with pmax;
#assert Game reaches gameEndConditionBoundedRoundP2Win with prob;

#assert Game deadlockfree;